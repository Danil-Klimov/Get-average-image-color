{"version":3,"sources":["App.tsx","serviceWorker.ts","index.tsx"],"names":["override","css","canvas","document","createElement","ctx","getContext","getAverageColor","greenlet","imageData","a","len","length","pixelsCount","arraySum","i","join","App","useState","isOver","setIsOver","fileData","setFileData","bgColor","setBgColor","isLoading","setIsLoading","imageRef","useRef","useEffect","current","image","height","naturalHeight","offsetHeight","width","naturalWidth","offsetWidth","getImageSize","drawImage","getImageData","data","then","res","className","style","backgroundColor","classnames","onDrop","e","preventDefault","stopPropagation","reader","FileReader","onloadend","result","readAsDataURL","dataTransfer","files","onDragOver","onDragEnter","onDragLeave","ref","alt","src","toString","size","loading","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","getElementById","navigator","serviceWorker","ready","registration","unregister","catch","error","console","message"],"mappings":"2dAOA,IAAMA,EAAWC,cAAH,KAMRC,EAASC,SAASC,cAAc,UAChCC,EAAMH,EAAOI,WAAW,MAExBC,EAAkBC,YAAQ,uCAAC,WAAOC,GAAP,qBAAAC,EAAA,sDAK/B,IAJMC,EAAMF,EAAUG,OAChBC,EAAcF,EAAM,EACpBG,EAAqB,CAAC,EAAG,EAAG,EAAG,GAE5BC,EAAI,EAAGA,EAAIJ,EAAKI,GAAK,EAC5BD,EAAS,IAAML,EAAUM,GACzBD,EAAS,IAAML,EAAUM,EAAI,GAC7BD,EAAS,IAAML,EAAUM,EAAI,GAC7BD,EAAS,IAAML,EAAUM,EAAI,GATA,wCAYhB,IACVD,EAAS,GAAKD,MACdC,EAAS,GAAKD,MACdC,EAAS,GAAKD,MACdC,EAAS,GAAKD,IACjBG,KAAK,KAjBwB,iDAAD,uDA8GjBC,MA9Ef,WAAgB,IAAD,EACeC,oBAAS,GADxB,mBACNC,EADM,KACEC,EADF,OAEmBF,qBAFnB,mBAENG,EAFM,KAEIC,EAFJ,OAGiBJ,mBAAS,4BAH1B,mBAGNK,EAHM,KAGGC,EAHH,OAIqBN,oBAAS,GAJ9B,mBAINO,EAJM,KAIKC,EAJL,KAKPC,EAAWC,iBAAyB,MAqD1C,OAnDAC,qBAAU,WACR,GAAIF,EAASG,QAAS,CACpB,IAAMC,EAAQJ,EAASG,QADH,EApB1B,SAAsBC,GAMpB,MAAO,CACLC,OANc9B,EAAO8B,OACrBD,EAAME,eAAiBF,EAAMG,cAAgBH,EAAMC,OAMnDG,MALajC,EAAOiC,MACpBJ,EAAMK,cAAgBL,EAAMM,aAAeN,EAAMI,OAkBrBG,CAAaP,GAA/BC,EAFY,EAEZA,OAAQG,EAFI,EAEJA,MAEhB9B,EAAKkC,UAAUR,EAAO,EAAG,GAEzBxB,EAAgBF,EAAKmC,aAAa,EAAG,EAAGL,EAAOH,GAAQS,MAAMC,MAC3D,SAACC,GACCnB,EAAWmB,GACXjB,GAAa,SAIlB,CAACC,EAAUN,IAsCZ,yBAAKuB,UAAU,OACb,yBACEC,MAAO,CAAEC,gBAAiBvB,GAC1BqB,UAAWG,IAAW,YAAa,CAAE,iBAAkB5B,IACvD6B,OAxCN,SAAgBC,GACdA,EAAEC,iBACFD,EAAEE,kBAEFzB,GAAa,GAEb,IAAI0B,EAAS,IAAIC,WACjBD,EAAOE,UAAY,WACjBhC,EAAY8B,EAAOG,SAGrBH,EAAOI,cAAcP,EAAEQ,aAAaC,MAAM,IAE1CtC,GAAU,IA4BNuC,WAzBN,SAAoBV,GAClBA,EAAEC,iBACFD,EAAEE,mBAwBES,YArBN,SAAqBX,GACnBA,EAAEC,iBACFD,EAAEE,kBAEF/B,GAAU,IAkBNyC,YAfN,SAAqBZ,GACnBA,EAAEC,iBACFD,EAAEE,kBAEF/B,GAAU,KAaLC,EACC,yBAAKyC,IAAKnC,EAAUoC,IAAI,UAAUC,IAAK3C,EAAS4C,aAC9C,KAEJ,kBAAC,IAAD,CAAYhE,IAAKD,EAAUkE,KAAM,IAAKC,QAAS1C,OC5GnC2C,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2DCZNC,IAASC,OACP,kBAAC,IAAMC,WAAP,KACE,kBAAC,EAAD,OAEFxE,SAASyE,eAAe,SDiIpB,kBAAmBC,WACrBA,UAAUC,cAAcC,MACrBrC,MAAK,SAAAsC,GACJA,EAAaC,gBAEdC,OAAM,SAAAC,GACLC,QAAQD,MAAMA,EAAME,c","file":"static/js/main.3dae33e4.chunk.js","sourcesContent":["import React, { useState, useEffect, useRef } from \"react\";\nimport classnames from \"classnames\";\nimport greenlet from \"greenlet\";\nimport ClipLoader from \"react-spinners/ClipLoader\";\nimport { css } from \"@emotion/core\";\nimport \"./App.css\";\n\nconst override = css`\n  display: block;\n  margin: 0 auto;\n  border-color: red;\n`;\n\nconst canvas = document.createElement(\"canvas\");\nconst ctx = canvas.getContext(\"2d\");\n\nconst getAverageColor = greenlet(async (imageData: Uint8ClampedArray) => {\n  const len = imageData.length;\n  const pixelsCount = len / 4;\n  const arraySum: number[] = [0, 0, 0, 0];\n\n  for (let i = 0; i < len; i += 4) {\n    arraySum[0] += imageData[i];\n    arraySum[1] += imageData[i + 1];\n    arraySum[2] += imageData[i + 2];\n    arraySum[3] += imageData[i + 3];\n  }\n\n  return `rgba(${[\n    ~~(arraySum[0] / pixelsCount),\n    ~~(arraySum[1] / pixelsCount),\n    ~~(arraySum[2] / pixelsCount),\n    ~~(arraySum[3] / pixelsCount),\n  ].join(\",\")})`;\n});\n\nfunction getImageSize(image: HTMLImageElement) {\n  const height = (canvas.height =\n    image.naturalHeight || image.offsetHeight || image.height);\n  const width = (canvas.width =\n    image.naturalWidth || image.offsetWidth || image.width);\n\n  return {\n    height,\n    width,\n  };\n}\n\nfunction App() {\n  const [isOver, setIsOver] = useState(false);\n  const [fileData, setFileData] = useState<string | ArrayBuffer | null>();\n  const [bgColor, setBgColor] = useState(\"rgba(255, 255, 255, 255)\");\n  const [isLoading, setIsLoading] = useState(false);\n  const imageRef = useRef<HTMLImageElement>(null);\n\n  useEffect(() => {\n    if (imageRef.current) {\n      const image = imageRef.current;\n      const { height, width } = getImageSize(image);\n\n      ctx!.drawImage(image, 0, 0);\n\n      getAverageColor(ctx!.getImageData(0, 0, width, height).data).then(\n        (res) => {\n          setBgColor(res);\n          setIsLoading(false);\n        }\n      );\n    }\n  }, [imageRef, fileData]);\n\n  function onDrop(e: React.DragEvent<HTMLDivElement>) {\n    e.preventDefault();\n    e.stopPropagation();\n\n    setIsLoading(true);\n\n    let reader = new FileReader();\n    reader.onloadend = () => {\n      setFileData(reader.result);\n    };\n\n    reader.readAsDataURL(e.dataTransfer.files[0]);\n\n    setIsOver(false);\n  }\n\n  function onDragOver(e: React.DragEvent<HTMLDivElement>) {\n    e.preventDefault();\n    e.stopPropagation();\n  }\n\n  function onDragEnter(e: React.DragEvent<HTMLDivElement>) {\n    e.preventDefault();\n    e.stopPropagation();\n\n    setIsOver(true);\n  }\n\n  function onDragLeave(e: React.DragEvent<HTMLDivElement>) {\n    e.preventDefault();\n    e.stopPropagation();\n\n    setIsOver(false);\n  }\n\n  return (\n    <div className=\"App\">\n      <div\n        style={{ backgroundColor: bgColor }}\n        className={classnames(\"drop-zone\", { \"drop-zone-over\": isOver })}\n        onDrop={onDrop}\n        onDragOver={onDragOver}\n        onDragEnter={onDragEnter}\n        onDragLeave={onDragLeave}\n      >\n        {fileData ? (\n          <img ref={imageRef} alt=\"Preview\" src={fileData.toString()}></img>\n        ) : null}\n\n        <ClipLoader css={override} size={150} loading={isLoading} />\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}